<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<meta name="viewport" content="initial-scale = 1.0, maximum-scale=1.0, user-scalable = no, width=device-width" />
	<meta name="apple-mobile-web-app-capable" content="yes" />

	<title>Безопасный город / Создание события</title>
	<!-- styles -->
	<link rel="stylesheet" href="dry/css/leaflet.css">
	<link rel="stylesheet" href="dry/css/leaflet.draw.css">
	
</head>
<body>
	
			<div id="map-container"></div>
			
	
	<script src="dry/js/leaflet.js"></script>
	<script src="dry/js/leaflet.draw.js"></script>
	<script>
		L.EditToolbar.Delete = L.Handler.extend({
    statics: {
        TYPE: 'remove' // not delete as delete is reserved in js
    },

    includes: L.Mixin.Events,

    initialize: function (map, options) {
        L.Handler.prototype.initialize.call(this, map);

        L.Util.setOptions(this, options);

        // Store the selectable layer group for ease of access
        this._deletableLayers = this.options.featureGroup;

        if (!(this._deletableLayers instanceof L.FeatureGroup)) {
            throw new Error('options.featureGroup must be a L.FeatureGroup');
        }

        // Save the type so super can fire, need to do this as cannot do this.TYPE :(
        this.type = L.EditToolbar.Delete.TYPE;
    },

    enable: function () {
        if (this._enabled || !this._hasAvailableLayers()) {
            return;
        }

        //console.log('enable');
        L.Handler.prototype.enable.call(this);

        this._deletableLayers
            .on('layeradd', this._enableLayerDelete, this)
            .on('layerremove', this._disableLayerDelete, this);

        this.fire('enabled', { handler: this.type});
        this._map.fire('draw:editstart', { handler: this.type });
    },

    disable: function () {
        if (!this._enabled) { return; }

        L.Handler.prototype.disable.call(this);

        this._deletableLayers
            .off('layeradd', this._enableLayerDelete, this)
            .off('layerremove', this._disableLayerDelete, this);

        this.fire('disabled', { handler: this.type});
        this._map.fire('draw:editstop', { handler: this.type });
    },

    addHooks: function () {
        if (this._map) {
            this._deletableLayers.eachLayer(this._enableLayerDelete, this);
            this._deletedLayers = new L.layerGroup();

            this._tooltip = new L.Tooltip(this._map);
            this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.remove.tooltip.text });

            this._map.on('mousemove', this._onMouseMove, this);
        }
    },

    removeHooks: function () {
        if (this._map) {
            this._deletableLayers.eachLayer(this._disableLayerDelete, this);
            this._deletedLayers = null;

            this._tooltip.dispose();
            this._tooltip = null;

            this._map.off('mousemove', this._onMouseMove, this);
        }
    },

    revertLayers: function () {
        console.log('_revertLayers');
        // Iterate of the deleted layers and add them back into the featureGroup
        this._deletedLayers.eachLayer(function (layer) {
            this._deletableLayers.addLayer(layer);
        }, this);
    },

    save: function () {
        this._map.fire('draw:deleted', { layers: this._deletedLayers });
    },

    _enableLayerDelete: function (e) {
        var layer = e.layer || e.target || e;
        console.log('_enableLayerDelete',layer._leaflet_id);
        layer.on('click', this._removeLayer, this);
    },

    _disableLayerDelete: function (e) {
        var layer = e.layer || e.target || e;
        console.log('_disableLayerDelete',layer._leaflet_id);
        layer.off('click', this._removeLayer, this);

        // Remove from the deleted layers so we can't accidently revert if the user presses cancel
        this._deletedLayers.removeLayer(layer);
    },

    _removeLayer: function (e) {
        var layer = e.layer || e.target || e;
        console.log('_removeLayer',layer._leaflet_id,layer);
        this._deletableLayers.removeLayer(layer);
        this._deletedLayers.addLayer(layer);
    },

    _onMouseMove: function (e) {
        this._tooltip.updatePosition(e.latlng);
    },

    _hasAvailableLayers: function () {
        return this._deletableLayers.getLayers().length !== 0;
    }
});

    
    var data = [{
    "type": "Feature",
    "geometry": {
        "type": "Polygon",
        "coordinates": [
          [
            [2.504410743713379,44.28253972334941],
            [2.504410743713379,44.28929846767132],
            [2.5168561935424805,44.28929846767132],
            [2.5168561935424805,44.28253972334941],
            [2.504410743713379,44.28253972334941]
          ]
        ]
      }
}]

var map = L.map('map-container').setView([44.285992,2.511021],14);

L.tileLayer('http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png').addTo(map);

var drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

var drawControl = new L.Control.Draw({
    edit: {
        featureGroup: drawnItems
    }
});

map.addControl(drawControl);
map.on('draw:created',function(e) {
    e.layer.addTo(drawnItems);
});

var geojsonLayer = L.geoJson(data);
geojsonLayer.getLayers()[0].addTo(drawnItems);

/*
setTimeout(function(){
  // Remove geojson layers after 2 seconds (this work)
  drawnItems.removeLayer(geojsonLayer);
},2000);
*/
	</script>
</body>
</html>